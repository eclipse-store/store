= User Interaction

This page provides detailed examples for configuring the user interaction level during Legacy Type Mapping.

== Accessing the Configuration

The Legacy Type Mapping resultor is configured through the connection foundation inside the storage foundation:

[source, java]
----
EmbeddedStorageFoundation<?> foundation = EmbeddedStorage.Foundation();
----

Access the connection foundation directly:

[source, java]
----
EmbeddedStorageConnectionFoundation<?> cf = foundation.getConnectionFoundation();
cf.setLegacyTypeMappingResultor(...);
----

Or use the callback style for method chaining:

[source, java]
----
foundation.onConnectionFoundation(f ->
{
    f.setLegacyTypeMappingResultor(...);
});
----

== Resultor Options

=== Silent (Default)

Accepts all heuristic mappings without any output or interaction.
This is the default when no resultor is configured.

[source, java]
----
f.setLegacyTypeMappingResultor(
    PersistenceLegacyTypeMappingResultor.New()
);
----

Best for: production environments, CI/CD pipelines, automated deployments.

=== Console Printing

Prints all detected mappings to the console but accepts them automatically.

[source, java]
----
f.setLegacyTypeMappingResultor(
    PrintingLegacyTypeMappingResultor.New(
        PersistenceLegacyTypeMappingResultor.New()
    )
);
----

Best for: development, debugging, verifying that mappings are correct during testing.

=== Interactive Inquiry

Prints the mapping and asks the user to type `y` to accept before proceeding.

[source, java]
----
f.setLegacyTypeMappingResultor(
    InquiringLegacyTypeMappingResultor.New(
        PersistenceLegacyTypeMappingResultor.New()
    )
);
----

Best for: local development when making class changes, first-time migration verification.

=== Interactive with Similarity Threshold

Only asks for confirmation when a field match has a similarity score below the threshold.

[source, java]
----
f.setLegacyTypeMappingResultor(
    InquiringLegacyTypeMappingResultor.New(
        PersistenceLegacyTypeMappingResultor.New(),
        0.8 // threshold: 0.0 to 1.0
    )
);
----

Best for: situations where most mappings are trivial but you want to catch ambiguous ones.

== Understanding the Threshold

A field mapping is considered "clear" (no inquiry needed) if:

1. The old and new fields are identical (similarity = 1.0), or
2. The mapping is explicitly defined in a refactoring CSV file

A field mapping is considered "unclear" if the similarity score is below the threshold.

Special case: if a field is *implicitly discarded* (the heuristic could not find a match, and it was not explicitly marked for deletion), an inquiry is *always* triggered regardless of the threshold.

=== Threshold Values

[options="header",cols="1,3"]
|===
|Value
|Behavior

|`1.0` (default)
|Always ask — only exact matches and explicit mappings are considered clear

|`0.9`
|Ask if any match is below 90% similar

|`0.7`
|Ask if any match is below 70% similar

|`0.0`
|Never ask (except for implicitly discarded fields)
|===

== Worked Example: Threshold in Practice

Given this refactoring:

[source, java, title="Person.java (old)"]
----
public class Person
{
    int    customerid;  // → pin (renamed, type change)
    String firstname;   // → firstName (case change)
    String surname;     // → lastName (renamed)
    String comment;     // removed (NOT related to commerceId)
}
----

[source, java, title="Person.java (new)"]
----
public class Person
{
    Integer pin;        // from customerid
    String  firstName;  // from firstname
    String  lastName;   // from surname
    String  commerceId; // new field
    Address address;    // new field
}
----

=== Without Explicit Mapping

The heuristic produces:

[source, text]
----
             [***new***] pin
firstname    -0.944 ----> firstName
surname      -0.688 ----> lastName
comment      -0.750 ----> commerceId     <-- WRONG
             [***new***] address
customerid   [discarded]                 <-- WRONG
----

Problems:

* `customerid` → `pin` is too dissimilar for the heuristic (different names, different types)
* `comment` → `commerceId` scores 0.75 similarity but is semantically wrong

=== With Explicit Mapping

Add two entries to `refactorings.csv`:

[source, text, title="refactorings.csv"]
----
old                              current
com.myapp.Person#customerid      com.myapp.Person#pin
com.myapp.Person#comment
----

Now the mapping is correct:

[source, text]
----
customerid   -[mapped] -> pin
firstname    -0.944 ----> firstName
surname      -0.688 ----> lastName
             [***new***] commerceId
             [***new***] address
comment      [discarded]
----

=== Threshold Behavior with This Mapping

With the explicit mapping above:

* *Threshold 0.7 or higher* → inquiry triggered, because `surname` → `lastName` scores 0.688 (below 0.7)
* *Threshold 0.6 or lower* → no inquiry, all matches are above threshold or explicitly mapped
* *Threshold 1.0* → inquiry triggered, because `firstname` → `firstName` is 0.944 (below 1.0)
* *Threshold 0.0* → no inquiry (no implicitly discarded fields remain)

== Custom Resultor Implementation

You can implement a completely custom resultor by implementing `PersistenceLegacyTypeMappingResultor`:

[source, java]
----
f.setLegacyTypeMappingResultor(
    (legacyTypeMapping) ->
    {
        // Log to your preferred logging framework
        logger.info("Legacy type mapping: {}", legacyTypeMapping);

        // Optionally write confirmed mappings to a file
        writeMappingToFile(legacyTypeMapping);

        // Return the mapping result (accept all)
        return PersistenceLegacyTypeMappingResult.New(legacyTypeMapping);
    }
);
----

Use cases for custom resultors:

* Logging to a file or logging framework instead of the console
* Writing confirmed mappings to the refactoring CSV for future determinism
* Integrating with external approval workflows
* Sending notifications when schema changes are detected
